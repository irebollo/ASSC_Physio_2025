%% Tutorial Script 4: permutationControl_GroupStats
%
% This script performs the permutation control analysis for the GLM HER ~ resRT.
% We run the same group analysis but on n_permutations times pseudo-randomly generated HER
% data (see Compute_permuted_HERs), and compute a Monte-Carlo p expressing the 
% probability of finding the statistic (maxsumT) as we did empirically.
% With this control, we check that our effect on reaction times is time-locked 
% (i.e. specific to) heartbeats, instead of being also found in heartbeat-unrelated
% pre-stimulus EEG activity.
%
% The permuted HER data is generated by permuting, for each subject and block, 
% the onset of R peaks relative to stimulus onset.
% The new semi-random "R peaks" are then used as events around which to cut 
% out new permuted "HER" epochs. This is repeated n_permutations times.
% The epoch definition has been done already in Compute_permuted_HERs.
% For each permutation round and each subject, this script now: (1) cuts EEG data 
% accordingly, appends data from all blocks, and (2) runs the GLM on the
% permuted data. Then it (3) runs group statistics on this permutation round's
% betas pooled across all subjects as in the main analysis. Finally, it
% (4) retrieves each permutation round's maxsumT statistic, and (5) computes 
% Monte-Carlo p based on the null distribution of maxsumT. It also plots a histogram 
% of that distribution.
%
% !!! 
% In practice, we only have the data for subject 26 (index 18 in our included_subjects 
% list) so we are commenting out the looping and just running the script
% for this subject, up to line 174 after which obviously for group stat
% results the rest of the subjects' data would be necessary.
% !!!
%
% INPUTS: To set in INIT
% - paths
% - included_subjects
% - all_blocks = list of block names ran per subject
% - n_permutations: How many permutations will be run? needs to match the number of trialDef_Rpeaks_permuted
% The function also loads, per subject:
% - <filePrefix>_desc-ICAcardio_bp-0525_eeg.mat containing data_eeg_ICAcardio_bp: 
%       fully preprocessed, bandpass-filtered, continuous EEG data
% - <filePrefix>_permutedHER_events.mat, containing trialDef_Rpeaks_allPermutations_allBlocks
%       n_permutations new "HER" epoch definitions per block, output of Compute_permuted_HERs.m. 
% - <filePrefix>_resRTs.mat, containing resRT: residual RT for each trial, the regressor in our GLM
%
% FUNCTIONS CALLED:
% - FieldTrip
% - INTESPACE_find_maxstat
% - My_GLM
%
% OUTPUTS:
% - maxsumt_allStats_allPermutations: All maxsumT resulting from n_permutations
% - nrLargerMaxsumt: Number of maxsumT larger than our main results
% - probabilityOfResult: Monte-Carlo p of finding the results that we did
% - Histogram of maxsumT distribution
%
% AUTHOR:
% Marie Loescher - July 2025


%% INIT

clear all

% Defining and adding paths
paths = TUTORIAL_setPaths();

% Fieldtrip
restoredefaultpath;
addpath([paths.fieldtrip])
ft_defaults

addpath(genpath([paths.main]));

load([paths.main 'Data' filesep 'included_subjects.mat'],'included_subjects')
all_blocks = ["01","02","03","04","05"];

n_permutations = 500; % needs to match the number of trialDef_Rpeaks_permuted


%% Pool everyone's continuous EEG data into one big structure

% Load all subject's continuous, fully preprocessed EEG data and store in one big structure
for subject = 18 % 1:length(included_subjects) % we skip the loop and only run on our example subject
    subject_nr = convertStringsToChars(included_subjects(subject))

    for block = 1:length(all_blocks)
        block_nr = convertStringsToChars(all_blocks(block));
        load([paths.main 'Data' filesep 'sub-' subject_nr filesep 'sub-' subject_nr '_block-' block_nr '_desc-ICAcardio_bp-0525_eeg.mat'],'data_eeg_ICAcardio_bp');
        allData{subject,block} = data_eeg_ICAcardio_bp; clear data_eeg_ICAcardio_bp
    end
end


%% Start looping over permutations

% For each existing permuted trialDef_Rpeaks, cut EEG data accordingly into
% new permuted "HER" epochs, retrieve behavioural data, and feed everything into the
% same GLM as for the main analysis. 


for permutation = 1:n_permutations

    for subject = 18 % 1:length(included_subjects) % we skip the loop and only run on our example subject
        subject_nr = convertStringsToChars(included_subjects(subject));

        % Get subjects' RT data (the regressor in our model)
        load([paths.main 'Data' filesep 'sub-' subject_nr filesep 'sub-' subject_nr '_resRTs.mat'], 'data_resRTs');


        %% Create permuted HER data for this permutation round
    
        % Load new HER epoch definitions with permuted timings
        load([paths.main 'Data' filesep 'sub-' subject_nr filesep 'sub-' subject_nr '_permutedHER_events.mat'],'trialDef_Rpeaks_allPermutations_allBlocks');
    
        for block = 1:length(all_blocks)
            block_nr = convertStringsToChars(all_blocks(block));

            % Retrieve this subject's and block's EEG data from the common structure
            this_eeg_data = allData{subject,block};
            % Retrieve this subject's and block's permuted epoch definition
            this_trialDef_Rpeaks = trialDef_Rpeaks_allPermutations_allBlocks{block,permutation};

            % Cut EEG data into new epochs
            cfg = [];
            cfg.trl = this_trialDef_Rpeaks;
            data_eeg_Rpeaks_permuted = ft_redefinetrial(cfg, this_eeg_data);

            % store and clean up
            data_eeg_Rpeaks_permuted_allBlocks{1,block} = data_eeg_Rpeaks_permuted;
            clear data_eeg_Rpeaks_permuted this_trialDef_Rpeaks this_eeg_data
        end
        % concatenate data across blocks
        data_HERs_permuted = ft_appenddata([], data_eeg_Rpeaks_permuted_allBlocks{1:end}); clear data_eeg_Rpeaks_permuted_allBlocks
    

        %% Run GLM (this is the same code as in Analyse_HER)

        % Organize data for GLM
        n_trials = length(data_HERs_permuted.trial);
        n_channels = length(data_HERs_permuted.label);
        n_timepoints = length(data_HERs_permuted.time{1,1});
        data_HERs_forGLM = nan(n_trials,n_channels,n_timepoints); % we are going to permute dimensions 2 and 3 below to fit requirements of My_glm.m
        for trial = 1:n_trials
            data_HERs_forGLM(trial,:,:) = data_HERs_permuted.trial{1,trial}(:,1:n_timepoints);
        end
        data_HERs_forGLM = permute(data_HERs_forGLM,[1,3,2]); % now data_eeg_forGLM = Trial x Time x Channel
        
        % Run GLM: HER ~ resRT        
        regressors = [data_resRTs];
        zflag = 1; % zscore HER data across repetitions, separately per channel and per timepoint
        [beta, intercept, residuals] = My_glm(data_HERs_forGLM, regressors, zflag);
        
        % Store in structure
        beta_HER_resRT.avg       = beta; 
        beta_HER_resRT.dimord    = 'time_chan'; 
        beta_HER_resRT.intercept = intercept; 
        beta_HER_resRT.residuals = residuals;
        beta_HER_resRT.time      = data_HERs_permuted.time{1,1};
        beta_HER_resRT           = copyfields(data_HERs_permuted,beta_HER_resRT,{'label'});
        

        %% Pool results across subjects for this permutation round

        beta_HER_resRT_all{subject}.avg     = transpose(beta_HER_resRT.avg); 
        beta_HER_resRT_all{subject}.time    = beta_HER_resRT.time; 
        beta_HER_resRT_all{subject}.label   = beta_HER_resRT.label; 
        beta_HER_resRT_all{subject}.dimord  = 'chan_time'; 
    
        % creating matching data that contains zero to perform the statistical analysis against
        beta_ZEROES{subject}.avg     = transpose(zeros(size(beta_HER_resRT.avg))); 
        beta_ZEROES{subject}.time    = beta_HER_resRT.time; 
        beta_ZEROES{subject}.label   = beta_HER_resRT.label; 
        beta_ZEROES{subject}.dimord  = 'chan_time'; 

        clear beta_HER_resRT
        
    end
   
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Script only runs up to here, we are missing the data for the rest of the subjects %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    %% Run group stats on all pooled subjects, once per permutation round (this is the same code as in GroupStats_HERs)

    % prepare neigbhours
    cfg             = [];
    cfg.channel     = 'all';
    cfg.method      = 'template';
    cfg.template    = 'biosemi64_neighb.mat';
    cfg.layout      = 'biosemi64.lay';  
    neighbours      = ft_prepare_neighbours(cfg);
    
    % create design matrix
    n_subjects = size(included_subjects,2);
    design = zeros(2,2*n_subjects);
    for i = 1:n_subjects
        design(1,i) = i;
    end
    for i = 1:n_subjects
        design(1,n_subjects+i) = i;
    end
    design(2,1:n_subjects) = 1;
    design(2,n_subjects+1:2*n_subjects) = 2;
    
    % Testing against zeroes
    disp(['Permutation nr ' num2str(permutation)])
    cfg = [];
    cfg.channel = {'all'};
    cfg.latency = [0.2 0.6]; % R peak = 0
    cfg.method = 'montecarlo';
    cfg.statistic = 'ft_statfun_depsamplesT';
    cfg.avgovertime = 'no';
    cfg.correctm = 'cluster';
    cfg.parameter = 'avg';
    cfg.clusterstatistic = 'maxsum';
    cfg.tail = 0; 
    cfg.clustertail = 0; 
    cfg.alpha = 0.05;
    cfg.correcttail = 'alpha'; % because we are performing two-sided t-tests
    cfg.numrandomization = 500; % we take a lower number of randomizations for permuted analysis to save computing power
    cfg.design = design;
    cfg.neighbours = neighbours;
    cfg.uvar  = 1; % the 1st row in cfg.design contains the subject number
    cfg.ivar  = 2; % the 2nd row in cfg.design contains the independent variable
    cfg.spmversion = 'spm12'; % MEX files in SPM 8 not compatible, must use spm12
    cfg.clusteralpha = 0.01;
    cfg.minnbchan = 1;
    stat_resRT  = ft_timelockstatistics(cfg, beta_HER_resRT_all{:}, beta_ZEROES{:});


    %% Store this permutation round's maxsumt for largest positive and negative candidate clusters

    [maxstat_pos, maxstat_neg] = INTESPACE_find_maxstat(stat_resRT);
    maxsumt_allStats_allPermutations.pos(permutation) = maxstat_pos;
    maxsumt_allStats_allPermutations.neg(permutation) = maxstat_neg; 
    clear stat_resRT

end


%% Compute permutation control results: Compare empirical maxsumt to distribution of largest permuted maxsumt's (Monte-Carlo p)

% Load empirical GLM results
load([paths.main 'Data' filesep 'group_results' filesep 'group_GLM-results.mat'], 'stat_resRT');

% Compute Monte-Carlo p for the clusters that have been found to be significant in main analysis
nrLargerMaxsumt.resRT_1 = sum(maxsumt_allStats_allPermutations.pos > stat_resRT.posclusters(1).clusterstat);
nrLargerMaxsumt.resRT_2 = sum(maxsumt_allStats_allPermutations.pos > stat_resRT.posclusters(2).clusterstat);

probabilityOfResult.resRT_pos_1 = nrLargerMaxsumt.resRT_1/n_permutations;
probabilityOfResult.resRT_pos_2 = nrLargerMaxsumt.resRT_2/n_permutations;

save([paths.main 'Data' filesep 'group_results' filesep 'group_permutationControl-results.mat'],'probabilityOfResult', 'nrLargerMaxsumt', 'maxsumt_allStats_allPermutations') 


% Histogram of permuted maxsumt values and empirical results
subplot(1,2,1)
histogram(maxsumt_allStats_allPermutations.pos)
xline(stat_resRT.posclusters(1).clusterstat,'r')
title(['resRT cluster 1'])
subtitle(['Monte-Carlo p = ' num2str(probabilityOfResult.resRT_pos_1)])
subplot(1,2,2)
histogram(maxsumt_allStats_allPermutations.pos)
xline(stat_resRT.posclusters(2).clusterstat,'r')
title(['resRT cluster 2'])
subtitle(['Monte-Carlo p = ' num2str(probabilityOfResult.resRT_pos_2)])
sgtitle(['MaxsumT distribution for permutations (N = ' num2str(n_permutations) ')'])
print([paths.main 'Data' filesep 'group_results' filesep 'group_permutationControl-results'],'-dpng') 

